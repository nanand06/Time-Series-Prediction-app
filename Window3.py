# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Window3.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from statsmodels.tsa.arima.model import ARIMA 
from statsmodels.tsa.statespace.sarimax import SARIMAX
import matplotlib.pyplot as plt
import pandas as pd
import torch.nn as nn
import torch
import torch.optim as optim

class Ui_MainWindow3(object):
    def __init__(self, f1):
        self.model_chosen = False
        self.f1 = f1
        #self.f1.min_max_normalization()
    def setupUi(self, MainWindow):

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(482, 414)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setStyleSheet("font: 20pt \"MS Shell Dlg 2\";")
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_3.addWidget(self.label_2)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.pushButton.clicked.connect(self.lstm_chosen)
        self.horizontalLayout_3.addWidget(self.pushButton)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.clicked.connect(self.arima_chosen)
        self.horizontalLayout_3.addWidget(self.pushButton_2)
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.clicked.connect(self.sarima_chosen)
        self.horizontalLayout_3.addWidget(self.pushButton_3)
        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.label_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_4.addWidget(self.label_3)
        self.label_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_4.setMinimumSize(QtCore.QSize(228, 126))
        self.label_4.setMaximumSize(QtCore.QSize(228, 16777215))
        self.label_4.setObjectName("label_4")
        self.horizontalLayout_4.addWidget(self.label_4)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_4)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Time Series Analysis "))
        self.label_2.setText(_translate("MainWindow", "Select Model Type: "))
        self.pushButton.setText(_translate("MainWindow", "LSTM"))
        self.pushButton_2.setText(_translate("MainWindow", "ARIMA"))
        self.pushButton_3.setText(_translate("MainWindow", "SARIMA"))
        self.label_3.setText(_translate("MainWindow", "Chosen Model:"))
        self.label_4.setText(_translate("MainWindow", "None"))
    def lstm_chosen(self):
        if self.model_chosen:
            last_item = self.verticalLayout_2.itemAt(self.verticalLayout_2.count() - 1).widget()
            last_item.deleteLater()
        self.label_4.setText("LSTM")
        self.verticalLayout_2.addWidget(LSTM(self.f1.selected_player_fastest_lap_times))
        self.model_chosen = True
        
    def arima_chosen(self):
        if self.model_chosen:
            last_item = self.verticalLayout_2.itemAt(self.verticalLayout_2.count() - 1).widget()
            last_item.deleteLater()
        self.label_4.setText("ARIMA")
        self.verticalLayout_2.addWidget(Arima(self.f1.selected_player_fastest_lap_times))
        self.model_chosen = True
    def sarima_chosen(self):
        if self.model_chosen:
            last_item = self.verticalLayout_2.itemAt(self.verticalLayout_2.count() - 1).widget()
            last_item.deleteLater()
        self.label_4.setText("SARIMA")
        self.verticalLayout_2.addWidget(Sarima(self.f1.selected_player_fastest_lap_times))
        self.model_chosen = True

class Arima(QtWidgets.QWidget):

    def __init__(self, player_data):
        super().__init__()
        self.time_series_data = player_data
        self.p = None
        self.q = None
        self.d = None
        self.vbox = QtWidgets.QVBoxLayout()
        hbox = QtWidgets.QHBoxLayout()


        self.p_label = QtWidgets.QLabel("Enter p Value")
        self.p_input = QtWidgets.QLineEdit()

        self.q_label = QtWidgets.QLabel("Enter d Value")
        self.q_input = QtWidgets.QLineEdit()

        self.d_label = QtWidgets.QLabel("Enter q Value")
        self.d_input = QtWidgets.QLineEdit()


        self.finalize = QtWidgets.QPushButton("Finalize Hyperparameter Selection")
        self.finalize.clicked.connect(self.deactivate_selection)

        self.run_model = QtWidgets.QPushButton("View Future Prediction(1 time step)")

        self.model_fit = QtWidgets.QPushButton("View Model fit")
        
        self.hbox1 = QtWidgets.QHBoxLayout()
        self.label1 = QtWidgets.QLabel("Prediction: ")
        self.label2 = QtWidgets.QLabel()

        self.hbox1.addWidget(self.label1)
        self.hbox1.addWidget(self.label2)
        
        self.model_fit.clicked.connect(self.view_model_fit)
        self.run_model.clicked.connect(self.implement_arima)
        hbox.addWidget(self.p_label)
        hbox.addWidget(self.p_input)
        hbox.addWidget(self.q_label)
        hbox.addWidget(self.q_input)
        hbox.addWidget(self.d_label)
        hbox.addWidget(self.d_input)
        self.vbox.addLayout(hbox)
        self.vbox.addWidget(self.finalize)
        self.vbox.addWidget(self.run_model)


        self.setLayout(self.vbox)
    def deactivate_selection(self):
        self.p_input.setEnabled(False)
        self.q_input.setEnabled(False)
        self.d_input.setEnabled(False)
        self.finalize.setEnabled(False)

        self.p = int(self.p_input.text())
        self.q = int(self.q_input.text())
        self.d = int(self.d_input.text())
    def implement_arima(self):
        print(self.time_series_data, self.p, self.d, self.q)
        self.arima_model = ARIMA(self.time_series_data, order = (self.p, self.d, self.q))
        self.arima_result = self.arima_model.fit()
        self.step_size = 5
        self.forecast = self.arima_result.forecast(steps=self.step_size)
        self.next_time_step = self.forecast[0]

        
        print(self.forecast)
        self.vbox.addLayout(self.hbox1)
        self.label2.setText(str(self.next_time_step))
        self.vbox.addWidget(self.model_fit)
        
    def view_model_fit(self):
        self.fitted_values = self.arima_result.fittedvalues
        forecast_index = range(len(self.time_series_data), len(self.time_series_data) + self.step_size)
        forecast_series = pd.Series(self.forecast, index=forecast_index)
        #plt.plot(self.time_series_data)
        plt.plot(self.fitted_values, label = "Actual DAta")
        plt.plot(self.time_series_data, 'r', label = "Fitted Data")
        plt.plot(forecast_series, 'b', label = "Forecasted Values")
        plt.xlabel("Fastest lap times for each Grand Prix(1950-2024)")
        plt.ylabel("Fastest Lap Times (seconds)")
        plt.legend()
        plt.show()
        pass
class Sarima(QtWidgets.QWidget):

    def __init__(self, time_series_data):
        super().__init__()
        self.time_series_data = time_series_data
        hbox1 = QtWidgets.QHBoxLayout()
        hbox2 = QtWidgets.QHBoxLayout()

        hbox = QtWidgets.QHBoxLayout()


        self.p_label = QtWidgets.QLabel("Enter p Value")
        self.p_input = QtWidgets.QLineEdit()

        self.q_label = QtWidgets.QLabel("Enter d Value")
        self.q_input = QtWidgets.QLineEdit()

        self.d_label = QtWidgets.QLabel("Enter q Value")
        self.d_input = QtWidgets.QLineEdit()

        hbox.addWidget(self.p_label)
        hbox.addWidget(self.p_input)
        hbox.addWidget(self.q_label)
        hbox.addWidget(self.q_input)
        hbox.addWidget(self.d_label)
        hbox.addWidget(self.d_input)

        self.vbox = QtWidgets.QVBoxLayout()
        self.P_label = QtWidgets.QLabel("Enter P Value")
        self.P_input = QtWidgets.QLineEdit()

        self.Q_label = QtWidgets.QLabel("Enter D Value")
        self.Q_input = QtWidgets.QLineEdit()

        self.D_label = QtWidgets.QLabel("Enter Q Value")
        self.D_input = QtWidgets.QLineEdit()
    
        hbox1.addWidget(self.P_label)
        hbox1.addWidget(self.P_input)
        hbox1.addWidget(self.Q_label)
        hbox1.addWidget(self.Q_input)
        hbox1.addWidget(self.D_label)
        hbox1.addWidget(self.D_input)

        self.m_label = QtWidgets.QLabel("Enter m value")
        self.m_input = QtWidgets.QLineEdit()

        hbox2.addWidget(self.m_label)
        hbox2.addWidget(self.m_input)
        
        self.finalize = QtWidgets.QPushButton("Finalize Hyperparameter Selection")
        self.finalize.clicked.connect(self.deactivate_selection)

        self.run_model = QtWidgets.QPushButton("View Future Prediction")
        self.run_model.clicked.connect(self.run_sarima)
        self.vbox.addLayout(hbox)
        self.vbox.addLayout(hbox1)
        self.vbox.addLayout(hbox2)
        self.vbox.addWidget(self.finalize)
        self.vbox.addWidget(self.run_model)
        self.setLayout(self.vbox)

        self.hbox3 = QtWidgets.QHBoxLayout()
        
        self.label1 = QtWidgets.QLabel()
        self.label1.setText("Prediction: ")

        self.label2 = QtWidgets.QLabel()

        self.hbox3.addWidget(self.label1)
        self.hbox3.addWidget(self.label2)

        self.model_fit = QtWidgets.QPushButton("View Model Fit")
        self.model_fit.clicked.connect(self.display_model_fit)
    def deactivate_selection(self):
        self.p_input.setEnabled(False)
        self.q_input.setEnabled(False)
        self.d_input.setEnabled(False)
        self.P_input.setEnabled(False)
        self.Q_input.setEnabled(False)
        self.D_input.setEnabled(False)
        self.m_input.setEnabled(False)
        self.finalize.setEnabled(False)
    def run_sarima(self):
        self.p = int(self.p_input.text())
        self.q = int(self.q_input.text())
        self.d = int(self.d_input.text())
        self.P = int(self.P_input.text())
        self.D = int(self.D_input.text())
        self.Q = int(self.Q_input.text())
        self.m = int(self.m_input.text())
        model = SARIMAX(self.time_series_data, 
                order=(self.p, self.d, self.q), 
                seasonal_order=(self.P, self.D, self.Q, self.m ), 
                enforce_stationarity=False, 
                enforce_invertibility=False)
        print("Fitting model...")
        self.fitted_model = model.fit(disp = False)
        print("Model fitted...")
        self.forecast = self.fitted_model.forecast(steps=5)    
        self.vbox.addLayout(self.hbox3)
        print(self.forecast)
        self.label2.setText(str(self.forecast[0]))
        self.vbox.addWidget(self.model_fit)
        print("Sarima Running...")
    def display_model_fit(self):
        plt.plot(self.time_series_data,  label='time series data')
        plt.plot(self.fitted_model.fittedvalues, 'b', label ='fitted values')
        plt.plot(self.forecast,'ro' ,label = 'predictions')
        plt.xlabel("Fastest lap times for each Grand Prix(1950-2024)")
        plt.ylabel("Fastest Lap Times (seconds)")
        plt.legend()
        plt.show()

class LSTM(QtWidgets.QWidget):

    def __init__(self, time_series_data):
        super().__init__()
        self.time_series_data = time_series_data
        self.min_max_normalization()
        self.sliding_window(12)
        self.training_loss = None
        self.hbox1 = QtWidgets.QHBoxLayout()
        self.hbox2 = QtWidgets.QHBoxLayout()

        self.vbox1 = QtWidgets.QVBoxLayout()

        self.hidden_size_label = QtWidgets.QLabel("Enter a Hidden Size")
        self.hidden_size_input = QtWidgets.QLineEdit()

        self.feature_size_label = QtWidgets.QLabel("Enter a Feature Size")
        self.feature_size_input = QtWidgets.QLineEdit()

        self.layer_size_label = QtWidgets.QLabel("Enter a Layer Size")
        self.layer_size_input = QtWidgets.QLineEdit()

        self.hbox1.addWidget(self.hidden_size_label)
        self.hbox1.addWidget(self.hidden_size_input)
        self.hbox1.addWidget(self.feature_size_label)
        self.hbox1.addWidget(self.feature_size_input)
        self.hbox1.addWidget(self.layer_size_label)
        self.hbox1.addWidget(self.layer_size_input)

        self.output_size_label = QtWidgets.QLabel("Enter an Ouptut Size")
        self.output_size_input = QtWidgets.QLineEdit()

        self.num_epochs_label = QtWidgets.QLabel("Enter a number of Epochs")
        self.num_epochs_input = QtWidgets.QLineEdit()

        self.hbox2.addWidget(self.output_size_label)
        self.hbox2.addWidget(self.output_size_input)
        self.hbox2.addWidget(self.num_epochs_label)
        self.hbox2.addWidget(self.num_epochs_input)

        self.finalize = QtWidgets.QPushButton("Finalize Hyperparameter Selection")
        self.finalize.clicked.connect(self.deactivate_selection)

        self.train_lstm = QtWidgets.QPushButton("Train LSTM")
        self.train_lstm.clicked.connect(lambda: self.train_LSTM(int(self.hidden_size_input.text()), 
        int(self.feature_size_input.text()), int(self.layer_size_input.text()), int(self.output_size_input.text()), 
        int(self.num_epochs_input.text())))
        self.training_metadata = QtWidgets.QLabel("Training MSE: ")

        self.test_lstm = QtWidgets.QPushButton("Test LSTM")
        self.testing_metadata = QtWidgets.QLabel("Testing MSE: ")
        self.test_lstm.clicked.connect(self.test_LSTM_model)
        self.run_model = QtWidgets.QPushButton("View Future Prediction")
        self.prediction_result = QtWidgets.QLabel("Prediction: ")
        self.run_model.clicked.connect(self.generate_prediction)
        self.vbox1.addLayout(self.hbox1)
        self.vbox1.addLayout(self.hbox2)
        self.vbox1.addWidget(self.finalize)
        self.vbox1.addWidget(self.train_lstm)
        self.vbox1.addWidget(self.training_metadata)
        self.vbox1.addWidget(self.test_lstm)
        self.vbox1.addWidget(self.testing_metadata)
        #self.vbox1.addWidget(self.test_lstm)
        self.vbox1.addWidget(self.run_model)
        self.vbox1.addWidget(self.prediction_result)
        self.setLayout(self.vbox1)
    def deactivate_selection(self):
        self.hidden_size_input.setEnabled(False)
        self.feature_size_input.setEnabled(False)
        self.layer_size_input.setEnabled(False)
        self.output_size_input.setEnabled(False)
        self.num_epochs_input.setEnabled(False)
        self.finalize.setEnabled(False)
    def generate_prediction(self):
        # hidden_size = int(self.hidden_size_input.text())
        # feature_size = int(self.feature_size_input.text())
        # layer_size = int(self.layer_size_input.text())
        # output_size = int(self.output_size_input.text())
        # epochs = int(self.num_epochs_input.text())
        
        #self.train_LSTM(hidden_size, feature_size, layer_size, output_size,epochs)

        prediction = self.predict_LSTM_model()
        self.prediction_result.setText(f"Prediction: {prediction}")
    def test_LSTM_model(self):
        test_X = torch.tensor(self.lstm_sequence_test_X)
        test_y = torch.tensor(self.lstm_seqwuence_test_y)
        #print(test_X.size(), test_y.size())
        print(test_X.shape)
        out = self.model.forward(test_X)
        #print(out.shape,test_y.shape )
        loss = self.loss_function(out, test_y)
        arc_pred = ((float(out[0]) + 1)/2) * (self.max - self.min) + self.min
        arc_actual = ((float(test_y[0]) + 1)/2) * (self.max - self.min) + self.min
        print(f"Testing Loss: {loss}, Model Prediction: {arc_pred}, Target: {arc_actual}")
         # batch_size, sequence, feature_size - X input
         # batch_size, hidden_size - y label
        self.testing_metadata.setText(f"Testing MSE: {loss}")
    def train_LSTM(self, hidden_size, feature_size, num_layers, output_size, num_epochs):
        # self.train_lstm.setEnabled(False)
        # self.train_lstm.setText("Training...")
        X = torch.tensor(self.lstm_sequences_x, requires_grad=True)
        y = torch.tensor(self.lstm_sequences_y)
        print(X.shape)
        self.model = LSTM_model(hidden_size, feature_size, num_layers, output_size )
        self.loss_function = nn.MSELoss()
        self.optimizer = optim.Adam(self.model.parameters(), lr=.001)
        
        for epoch in range(num_epochs):# train
            self.optimizer.zero_grad()
            out = self.model.forward(X)
            
            #if epoch == num_epochs - 10: print(out, y)
            #print(out.shape, y.shape)
            loss = self.loss_function(out, y)
           #   print()
            arc_pred = ((float(out[6]) + 1)/2) * (self.max - self.min) + self.min
            arc_actual = ((float(y[6]) + 1)/2) * (self.max - self.min) + self.min
            print(f"Epoch Num: {epoch + 1} Training Loss: {loss}, Model Prediction: {arc_pred}, Target: {arc_actual}")
            loss.backward()
            self.optimizer.step()
            self.training_loss = loss
        self.training_metadata.setText(f"Training MSE: {self.training_loss}")
    def min_max_normalization(self):
        self.selected_player_fastest_lap_times = torch.tensor(self.time_series_data, dtype= torch.float32)
        self.max = self.selected_player_fastest_lap_times.max()
        self.min = self.selected_player_fastest_lap_times.min()
        self.selected_player_fastest_lap_times = 2 * (self.selected_player_fastest_lap_times - self.min) / (self.max - self.min)  - 1
        self.selected_player_fastest_lap_times = list(self.selected_player_fastest_lap_times)
        self.selected_player_fastest_lap_times = [float(time) for time in self.selected_player_fastest_lap_times]
    def sliding_window(self, fixed_window_size, future_steps = 1):
        counter = 0
        self.sequence_length_X = fixed_window_size -1
        self.lstm_sequences_x = []
        self.lstm_sequences_y = []
        self.lstm_sequence_test_X = []
        self.lstm_seqwuence_test_y = []
        self.lstm_pred_sequence_X = []
        self.lstm_pred_sequence_y = []
        #self.lstm
        if fixed_window_size <= len(self.selected_player_fastest_lap_times): 
            # establish a training and testing limit 
            training_limit = int(.95 * len(self.selected_player_fastest_lap_times))
            sequence = None

            for i in range(training_limit):
                sequence = self.selected_player_fastest_lap_times[i:i + fixed_window_size] 
                sequence = [[feature] for feature in sequence]
                if counter % fixed_window_size==0:
                    #print(counter, fixed_window_size)
                    self.lstm_sequences_x.append(sequence[:-1])
                    self.lstm_sequences_y.append(sequence[-1])
                    #print(self.lstm_sequences_x.shape)
                    
                counter +=1
            counter+=1

            print(counter)
            # generate Test Sequence
            test_sequence = self.selected_player_fastest_lap_times[counter:]
            test_sequence = [[feature] for feature in test_sequence]
            self.lstm_sequence_test_X.append(test_sequence[:-1])
            self.lstm_seqwuence_test_y.append(test_sequence[-1])
            #print(self.lstm_seqwuence_test_y[0])
            # generate Entire series for prediction

            pred_sequence = self.selected_player_fastest_lap_times
            pred_sequence = [[feature] for feature in pred_sequence]
            self.lstm_pred_sequence_X.append(pred_sequence)
            
            
        else:
            print("Too large of a window size")
            return
    def predict_LSTM_model(self):
        X = torch.tensor(self.lstm_pred_sequence_X)

        out = self.model.forward(X)

        arc_pred = ((float(out[0]) + 1)/2) * (self.max - self.min) + self.min

        return arc_pred
class LSTM_model(nn.Module):
# input_size (batch_size, sequence_length, feature_size)

#
    def __init__(self, hidden_size, feature_size, num_layers, output_size):
        super().__init__()
        self.lstm = nn.LSTM(input_size = feature_size, hidden_size=hidden_size, batch_first=True, num_layers=num_layers)
        self.lc = nn.Linear(hidden_size, output_size)
        self.dropout = nn.Dropout(.1)

    def forward(self, X):
        lstm_out, (hn, cn)  = self.lstm(X) 
                # batch_size, sequence_length, hidden_size
        out = lstm_out[:, -1, :] # batch_size, hidden_size
    
        out = self.dropout(out)

        output = self.lc(out) # batch_size, output_size
        return output
        
# if __name__ == "__main__":
#     import sys
#     app = QtWidgets.QApplication(sys.argv)
#     MainWindow = QtWidgets.QMainWindow()
#     ui = Ui_MainWindow()
#     ui.setupUi(MainWindow)
#     MainWindow.show()
#     sys.exit(app.exec_())
